// Code generated by MockGen. DO NOT EDIT.
// Source: git.fogcdn.top/axe/protos/goout/schedule (interfaces: ScheduleClient)

// Package mock_schedule is a generated GoMock package.
package mock_schedule

import (
	context "context"
	schedule "git.fogcdn.top/axe/protos/goout/schedule"
	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
	reflect "reflect"
)

// MockScheduleClient is a mock of ScheduleClient interface
type MockScheduleClient struct {
	ctrl     *gomock.Controller
	recorder *MockScheduleClientMockRecorder
}

// MockScheduleClientMockRecorder is the mock recorder for MockScheduleClient
type MockScheduleClientMockRecorder struct {
	mock *MockScheduleClient
}

// NewMockScheduleClient creates a new mock instance
func NewMockScheduleClient(ctrl *gomock.Controller) *MockScheduleClient {
	mock := &MockScheduleClient{ctrl: ctrl}
	mock.recorder = &MockScheduleClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockScheduleClient) EXPECT() *MockScheduleClientMockRecorder {
	return m.recorder
}

// Create mocks base method
func (m *MockScheduleClient) Create(arg0 context.Context, arg1 *schedule.CreateRequest, arg2 ...grpc.CallOption) (*schedule.CreateResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Create", varargs...)
	ret0, _ := ret[0].(*schedule.CreateResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create
func (mr *MockScheduleClientMockRecorder) Create(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockScheduleClient)(nil).Create), varargs...)
}

// Filter mocks base method
func (m *MockScheduleClient) Filter(arg0 context.Context, arg1 *schedule.FilterRequest, arg2 ...grpc.CallOption) (*schedule.FilterResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Filter", varargs...)
	ret0, _ := ret[0].(*schedule.FilterResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Filter indicates an expected call of Filter
func (mr *MockScheduleClientMockRecorder) Filter(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Filter", reflect.TypeOf((*MockScheduleClient)(nil).Filter), varargs...)
}

// Get mocks base method
func (m *MockScheduleClient) Get(arg0 context.Context, arg1 *schedule.GetRequest, arg2 ...grpc.CallOption) (*schedule.GetResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(*schedule.GetResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get
func (mr *MockScheduleClientMockRecorder) Get(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockScheduleClient)(nil).Get), varargs...)
}

// SwitchStatus mocks base method
func (m *MockScheduleClient) SwitchStatus(arg0 context.Context, arg1 *schedule.SwitchStatusRequest, arg2 ...grpc.CallOption) (*schedule.SwitchStatusResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SwitchStatus", varargs...)
	ret0, _ := ret[0].(*schedule.SwitchStatusResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SwitchStatus indicates an expected call of SwitchStatus
func (mr *MockScheduleClientMockRecorder) SwitchStatus(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SwitchStatus", reflect.TypeOf((*MockScheduleClient)(nil).SwitchStatus), varargs...)
}

// Update mocks base method
func (m *MockScheduleClient) Update(arg0 context.Context, arg1 *schedule.UpdateRequest, arg2 ...grpc.CallOption) (*schedule.UpdateResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(*schedule.UpdateResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update
func (mr *MockScheduleClientMockRecorder) Update(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockScheduleClient)(nil).Update), varargs...)
}
